# GraphQL Workshop

The master of whisperers is starting to lose track of all the comings and goings in Westeros. He has decided to build a GraphQL API to keep track, and has demanded that you help him.

Good luck!

## Introduction

GraphQL is an open-source data query language for APIs, and a runtime for fulfilling those queries with existing data. It represents a new way to think about APIs compared to traditional methods like REST. This workshop will give you hands-on experience using GraphQL to master common API operations.

We will cover basic topics like fetching data from a GraphQL server using queries and mutations, writing schemas to describe what data can be queried, and getting to know the schema type system. At the end of the workshop you will be well equipped to implement your own - or query an existing - GraphQL API.

## Getting started

First, clone this project.

### Install Node.js

Install Node.js using your favourite package manager, or [download](https://nodejs.org/en/download/) it. The workshop is tested with version 12.1.0, but should also work for older (not too old) versions.

### Install dependencies

Open your terminal and navigate to the `node` folder. Then run

```bash
npm install
```

### Start GraphQL server

To start the server, run

```bash
npm run start
```

and open [http://localhost:4000](http://localhost:4000) in the browser. All changes to the API will restart the server.

You are now ready to start the exercises.

### Project structure

#### Frontend

We use [Apollo Client](https://www.apollographql.com/docs/react/) to consume data from our GraphQL server. The client is designed to help you quickly build a UI that fetches data with GraphQL.

- `client/src/index.js` is the main file of the client and is where Apollo and React are initialized.

- `client/src/queries.js` contains all query definitions used to fetch data from our GraphQL server

- `client/src/Characters.js` displays a list of all Game of Thrones characters available

- `client/src/Character.js` is a detail view of a single character selected from the character list

The folder `client/src-solution` contains a complete solution proposal for all tasks listed below. You may copy content from `client/src-solution` to `client/src` if you prefer not to focus on client tasks. Be sure to check that queries listed in `queries.js` match your server side schema definition.

#### Backend

We use [graphql-yoga](https://github.com/prisma/graphql-yoga), which enables us to focus on the functional parts of setting up a GraphQL server.

To solve the exercises, you only need to make changes to `index.js` and `schema.graphql`.

- `node/index.js` includes the setup for the GraphQL server, and the implementation of the resolvers. We will use an in-memory database, which includes all the files in the `node/data` folder. Import the data needed as done with `characters` in `index.js`. Remember that all changes to the API will restart the server, which means that the in-memory database will be reset as well.

- `node/schema.js` includes the GraphQL schemas for our API. All changes must be done within the `gql` template string. If there is a mismatch between the resolvers in `index.js` and the schema, the project will not compile.

### IDE

If you do not have a preferred IDE for node we recommend [vscode](https://code.visualstudio.com/download). There are multiple extensions available to get GraphQL syntax highlighting, for example https://marketplace.visualstudio.com/items?itemName=Prisma.vscode-graphql.

Your GraphQL server should now be running on [http://localhost:4000](http://localhost:4000). Open the browser to verify that you are running [GraphiQL](https://github.com/graphql/graphiql), which is one of the key benefits of GraphQL. It is an interactive documentation of the GraphQL API, where you can see the schema, read the autogenerated documentation and try out queries with autocomplete. Use it for all it is worth in the excersises.

We also provide a React client that is set up to consume data exposed from our GraphQL server. All client related tasks are marked with "Frontend" and are not required to finish the workshop. Follow the link below to read installation instructions for the client:

- [Client (React.js)](/client/README.md)

Your React.js app should now show a simple webpage on [http://localhost:3000](http://localhost:3000).
A neat trick to debug your application is to inspect the network requests for this page in your browser's developer console. GraphQL returns great error responses if something is wrong with the network request,

## Task 1 - Basic Queries

The GraphQL query language is basically about selecting fields on objects, which means that the client is in control. The GraphQL server will return only the fields asked for.

A query is built hierarchical, with a top-level `query`

```graphql
query {
  characters {
    id
  }
}
```

### a) Use the query above to list all character ids in GraphiQL.

The client decides which character fields it needs. It can ask for the id, name, and image like this:

```graphql
query {
  characters {
    id
    name
    image
  }
}
```

### b) Extend the query from a) to also list the `name` and `image` of each character.

Nested queries can be used to find information about a characters siblings:

```graphql
query {
  characters {
    name
    siblings {
      name
    }
  }
}
```

### c) Use a nested query to see the characters' siblings.

## Task 2 - Schemas and Types

The schema defines your GraphQL API's type system, and what is allowed to be executed in the GraphQL server. Calls from the client are validated and executed against the schema.

Every schema needs a root query type, defining the top level queries.

```graphql
type Query {
  characters: [Character]
}
```

The `characters` field is defined as a list of type `Character`.

```graphql
type Character {
  id: ID!
  name: String
  image: String
  allegiances: [String]
  siblings: [Character]
}
```

The `Character` type defines two fields of type `ID` and `String`. Both are one of the built in scalar types defined by GraphQL. A scalar type resolves to a single scalar object, which can't have sub-selections in a query. The scalar types are:

- Int: A signed 32‐bit integer
- Float: A signed double-precision floating-point value
- String: A UTF‐8 character sequence
- Boolean: `true` or `false`
- ID: Represents a unique identifier and is serialized in the same way as a String

For scalar types, you can just add a field to a type in your schema - and GraphQL will resolve it based on matching name in the data set.

The `!` behind `ID` simply means that the field is non-nullable.

### a) Add the field `allegiances` to the `Character` type. Use GraphiQL to find the allegiances of all characters.

### b) [Frontend] Add an image for each character in `Characters.js`.

## Task 3 - Resolvers

Resolvers are responsible for mapping the operations to actual functions. For the `Character` type, there is already defined one resolver - the one that resolved your query for siblings earlier.

With Javascript it would look something like this:

```js
const Character = {
  siblings: (root, args) => {
    return characters.filter(character =>
      root.siblingIds.includes(character.id)
    );
  }
};
```

All resolvers receives the `root` argument, which is the parent beeing resolved. To find all the siblings, the resolver filters all characters using the `siblingIds` list.

### a) Add lovers and spouses to `Character`. Remember to add it to your schema as well.

Up until now we have queried all characters, but we want to be able to get a specific character. The following query should return Bran Stark:

```graphql
query {
  character(name: "Bran Stark") {
    name
  }
}
```

To support this query you need to extend the `Query` type in your schema:

```graphql
type Query {
  characters: [Character]
  character(name: String): Character
}
```

Now we will make use of the `args` argument. Adding a `character` resolver like below will allow you to query a specific character by name.

```js
const Query = {
  characters: (root, args, context) => {
    return characters;
  },
  character: (root, args, context) => {
    return characters.find(char => char.name === args.name);
  }
};
```

### b) Add `character(name: String): Character` to the API.

```graphql
type House {
  id: ID!
  name: String
  words: String
  region: [String!]
  allegiances: [House!]
  members: [Character!]
}
```

### c) Add `House` to the API. Use GraphiQL to list all houses.

### d) Add to the API which house a character belongs to.

### e) [Frontend] Get the required data for a specific character in `Character.js` using `@apollo/react-hooks`'s `useQuery`-hook. You might need to update your server side GraphQL schema to get all required fields. Useful documentation can be found here: https://www.apollographql.com/docs/react/essentials/queries/

## Task 4 - Mutations

Mutations are the second main operation in GraphQL. It deals with creating, updating, and deleting data. As with the `Query` type in your schema, you will need to add a `Mutation` type. Let's imagine you are Jaime Lannister and that secrets are important to you - such that sometimes desperate actions are needed:

```graphql
type Mutation {
  pushFromWindow(name: String!): Character
}
```

### a) Implement the `pushFromWindow` mutation. This includes changes to both schema and resolver. This mutation should set the `isHealthy` field to false for the given character.

### b) [Frontend] Implement the `pushFromWindow` mutation in the `Push`-component in `Character.js`. Use `@apollo/react-hooks`'s `useMutation`-hook. Useful documentation can be found here: https://www.apollographql.com/docs/react/essentials/mutations/

It is not just in Westeros the action is happening. Across the Narrow Sea an important wedding is taking place. The ruggedly handsome Khal Drogo is marrying the beautiful Daenerys Targaryen.

### c) Make sure the wedding takes place. Create a mutation which takes two names as arguments.

```graphql
type Mutation {
  pushFromWindow(name: String!): Character
  marry(spouseName1: String!, spouseName2: String!): [Character]
}
```

Although the claim may be poor, Joffrey Baratheon manages to be crowned King of the Seven Kingdoms. We have to make sure our API keeps track.

### d) Give King Joffrey the following titles: The First of His Name, King of the Andals and the First Men, Lord of the Seven Kingdoms, and Protector of the Realm.

### e) [Frontend] Make it possible to add titles to a character by implementing a mutation in the `AddTitle`-component in `Character.js`

## Bonus task

### a) Add the seats to all the houses. To do this you need to define a `Castle` type with the necessary fields (check the data set).
